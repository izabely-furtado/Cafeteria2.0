{"name":"Cafeteria2.0","tagline":"EX-StructuralPatterns - Cafeteria  “Black & White”","body":"### Diagrama do Padrão Decorador\r\n\r\nO projeto foi feito com base em [Cafeteria](http://izabely-furtado.github.io/Cafeteria/), no link está representado os dados referentes aps padrões anteriormente utilizados, como o padrão criativo fábrica.\r\n\r\nQueremos que, dado um objeto Cafe, seja possível adicionar funcionalidades a ele, e somente a ele, em tempo de execução. Vamos ver a arquitetura sugerida pelo padrão decorador com o diagrama que o representa:\r\n\r\n\r\n\r\n### Explicação\r\n\r\nCerto, então todos os objetos possuem o mesmo tipo **Cafe**, esta classe define o que todos os objeto possuem e é igual a classe já feita antes. As classes de cafés concretas definem apenas os dados relativos a ela. \r\n\r\nVejamos o construtor da classe abstrata**FacricaCafe** :\r\n\r\n>       FabricaCafe(float preco){\r\n>         //setando o preço\r\n>         this.setPreco(preco);\r\n>         //colocando os ingredientes\r\n>         this.agua = this.criarAgua();\r\n>     }\r\n\r\n\r\nPara ter um  melhor parâmetro do que cada filho vai setar, segue como exemplo o construtor da classe **FabricaCafeExpresso** : \r\n\r\n\r\n>     private FabricaCafeExpresso() {\r\n>         super(2);\r\n>         this.acucar = this.criarAcucar();\r\n>         this.cafeSoluvel = this.criarCafeSoluvel();\r\n>         this.leiteLiq = this.criarLeiteLiq();\r\n>     }\r\n\r\n\r\nJá na classe abstrata do decorador temos o seguinte construtor:\r\n\r\n>    public CafeDecorator(FabricaCafe cafe, float preco) {\r\n>         super(preco);\r\n>         this.umCafe = cafe;\r\n>         this.setPreco(this.getPreco() + this.umCafe.getPreco());\r\n>         \r\n>     }\r\n\r\nAssim em cada classe concreta de complemento tem-se que está vai ter passado como parâmetro um **FabricaCafe** e este estará contido no complemento. Já o preço, o preço do complemento em si é somado ao preço do café já escolhido.\r\n\r\n### Motivação\r\n\r\n* Adiciona funcionalidades ao objeto em tempo de execução. \r\nNote bem que, ao contrário da herança que aplica funcionalidades a todos os objetos dela, o padrão decorator permite aplicar funcionalidades apenas a um objeto específico.\r\n\r\n* Possui uma flexibilidade maior que a herança estática. \r\n\r\n* Aplica apenas as funcionalidades necessárias ao objeto nós evitamos o problema de classes sobrecarregadas, que possuem funcionalidade que nunca são utilizadas.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}